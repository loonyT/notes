What is grant type? #
In OAuth 2.0, the term grant type refers to the way an application gets an access token. Each grant type is optimized for a particular use, whether that’s a web app, a native app, a device without the ability to launch a web browser, or server-to-server applications.

In this lesson, we will look at the Authorization Code grant type.

Authorization Code grant type #
The Authorization Code grant type is the most commonly used OAuth 2.0 grant type. It is used by both web apps and native apps to get an access token from the authorization server once the user has authorized. The Authorization Code flow is most suitable for websites and mobile apps that have a backend.

This type has the extra step of exchanging the authorization code for the access token. The exchange of authorization code for the access token takes place in the back channel. Due to this feature, it provides an additional layer of security.

Authorization Code grant type Working #
Now we will look at the detailed working of the Authorization Code grant type.

Step 1 => Authorization request #
In the first step, the client app (PicsArt) redirects the resource owner (the user) to the authorization server’s authorization endpoint. The app sends some query parameters which help the authorization server in identifying the client app and its intent.

The query parameters sent with the request are:

response_type: This parameter defines what is the type of response that is expected. In this flow it will be code.

client_id: This parameter defines the id of the client that needs access to the resource. In our example, it will be the client id of the PicsArt app.

You might be wondering: where does this client id come from? Every client app first needs to register with an authorization server. When a client gets registered with an authorization server, it is provided a unique client_id and client_secret, which it uses to identify itself to the authorization server.

redirect_uri: This is the URI where the authorization server redirect to once it has finished interacting with the resource owner.

scope: This parameter defines the resources to which access is being requested. This is not a mandatory parameter, and if it is not provided the authorization server provides access to default resources already defined for this client.

state: The application generates a random string and includes it in the request. It should then check that the same value is returned after the user authorizes the app. This is used to prevent CSRF attacks.

The complete request looks like this:

https://authorization.server.dummy.com/authorize
?response_type=code
&client_id=12345
&redirect_uri=https://client.dummy.com/callback
&scope=images_read
&state=abcde
The client opens this URL in a browser. The authorization server will present them with a prompt asking if they would like to authorize this application’s request.

Step 2 => Authorization response #
If the user provides consent to the authorization server, then the authorization server redirects the browser to the redirect_uri which was provided in the request. The authorization server sends the following parameters in the response:

code: This is the authorization code generated by the authorization server. This code is relatively short-lived and is bound to client_id, resource_owner, scopes and redirect_uri.

state: This is the same string that was passed with the request.

The response URL looks like:

https://authorization.server.dummy.com/callback
?code=hhdf6hsbhjG66hgtgfGGHJGCHJ
&state=abcde
Step 3 => Token request #
Once the client has received the authorization code, it can exchange the code with the access token by sending a post request to the token endpoint.

Following parameters are sent with the request to get the token:

grant_type: For this flow, the value will be authorization_code. This tells the token endpoint that the client is using Authorization Code grant type.

code: This is the code that was received in Authorization Response.

client_id: The client id of the client.

client_secret: This is the client secret. This field is to verify that the request is sent by a validly registered client and not by an attacker posing as the client.

POST /token/endpoint HTTP/1.1

  Host: authserver.dummy.com

grant_type=authorization_code
&code=hhdf6hsbhjG66hgtgfGGHJGCHJ
&client_id=12345
&client_secret=gh5Gdkj743HFG45udbfGfs
Step 4 => Token response #
The token endpoint verifies all the parameters in the request. It verifies that the code has not expired and the client id and client secret matches. If everything looks good, then the access token is returned.

HTTP/1.1 200 OK
Content-Type: application/json

{
  "access_token":"YT3774ghsghdj6t4GJT5hd",
  "token_type":"bearer",
  "expires_in":3600,
  "refresh_token":"YT768475hjsdbhdgby6434hdh",
  "scope":"images_read"
}
You might be thinking, “Why are there two steps to get the access token? Why do we need to first get the authorization code and then exchange it with the access token?”

To understand this you must first know about two concepts:

Front channel: Less secure browser/mobile app to the server channel.
Back channel: Highly secure server to server communication channel.
It is not safe to share the client secret and get the access token on the front channel.

Therefore, we first fetch the authorization code using the front channel and then request the access token using the back channel.
